/// Yeti standard library.

/*
 * Copyright (c) 2008-2012 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.std;

import java.lang.IllegalArgumentException;
import java.util.regex.Pattern;
import java.util.Map;

class FailureException(String what)
    extends RuntimeException(what)
end;

/// Identity function (I combinator). The argument value will be
/// returned as is (id x = x).
id x = x;

/**
 * Creates a new array containing elements from the init list.
 *
 * Arguments:
 *  init - elements in this list will be added into the new array
 *
 * Examples:
 *
 * Create an empty array and add some value:
 * : someArray = array [];
 * : push someArray "test";
 * 
 * Create an array containing some given elements:
 * : numbers = array [1..5];
 */
array l is list?<'a> -> array<'a> =
    new MList(l) unsafely_as array<'a>;

/**
 * Creates and returns a lazy list concatenating a sequence of sequences
 * (flattening it).
 *
 * Arguments:
 * sequence - a sequence of sequences
 *
 * Description:
 * The elements of sequences in the given sequence argument are all concanated
 * together in the same order. The resulting list is created lazily,
 * as consumed (and the concat argument is also consumed lazyly, as needed).
 *
 * The result is affected (and unspecified), when array(s) are given as
 * concat argument and mutated before consuming the resulting list. A strict
 * result list or array can be created by applying copy or array function
 * to the lazy list returned by concat (for example (copy . concat)).
 *
 * Examples:
 * : concat [[3..6], [5..7], [4]]
 * The result is [3, 4, 5, 6, 5, 6, 7, 4].
 */
concat l is list?<list?<'a>> -> list<'a> =
    if empty? l then
        []
    else
        ConcatLists#concat(l) unsafely_as list<'a>
    fi;

/**
 * Takes value and first element of the sequence and applies those to the given
 * function, then repeats with following sequence elements, using the result from
 * previous application as the new value. Returns the result of last
 * application (or initial value when empty sequence was given).
 *
 * Arguments:
 *  function - two-argument function used for folding
 *  value - initial value
 *  sequence - list or array to fold
 *
 * Examples:
 * : fold function value [a, b, c]
 *
 * is equivalent to:
 * : ((value `function` a) `function` b) `function` c
 *
 * Calculate a sum of sequence:
 * : sum l = fold (+) 0 l;
 *
 * Calculate a factorial:
 * : factorial n = fold (*) 1 [1..n];
 *
 * The fold function could be implemented in the following way:
 * : fold function value sequence =
 * :     case sequence of
 * :     x :: xs: fold function (function value x) xs;
 * :     _: value;
 * :     esac;
 */
fold f is ('a -> 'b -> 'a) -> 'a -> list?<'b> -> 'a =
   (f2 v l is 'a -> list?<'b> -> 'a = // hack to get good code for gc
        if nullptr? l then
            v
        else
            (l unsafely_as ~AList)#fold(f, v) unsafely_as 'a
        fi;
    f2);

/**
 * Finds a list element, for which the predicate function returns true
 * and returns the list tail starting from that element, or empty list
 * when the given predicate isn't true for any list element.
 *
 * Arguments:
 *  predicate - function that returns true for the searched value
 *  list      - list to be searched
 *
 * Examples:
 *  : find (== 3) [1..5] // gives a list [3, 4, 5]
 */
find f l is ('a -> boolean) -> list?<'a> -> list<'a> =
    if nullptr? l then
        []
    else
        (l unsafely_as ~AList)#find(f) unsafely_as list<'a>
    fi;

/**
 * Returns 0-based index of the first list element, which equals
 * to the given value (using == for equality).
 *
 * Arguments:
 *  value - value to search for
 *  list  - list to be searched
 *
 * Examples:
 *  : index (== 'apple') ['oranges', 'apples', 'rats'] // returns 1
 */
index v l is 'a -> list?<'a> -> number =
    if nullptr? l then
        -1
    else
        res = (l unsafely_as ~AList)#index(v);
        if nullptr? res then -1 else res fi
    fi;

/**
 * Returns list of hash map keys.
 *
 * Arguments:
 *  hash - the hash map
 */
keys h is hash<'a, 'b> -> list<'a> =
    if empty? h then
        []
    else
        new MList((h unsafely_as ~Map)#keySet()#toArray())
            unsafely_as list<'a>
    fi;

/**
 * Creates a hash mapping from given list elements to unit values (you can
 * think of it being a set). As the hash map is essentially unordered,
 * the ordering that was present in the given list will be lost.
 *
 * Arguments:
 *  list - values to use as hash keys
 *
 * Examples:
 * : hash [11, 22] == [11: (), 22: ()]
 */
hash l is list?<'a> -> hash<'a, ()> =
   (h = [:];
    for l (_ i = h.[i] := ());
    h);

/**
 * Iterates over hash map, calling the block function for each
 * hash map entry with key and value as arguments.
 *
 * Arguments:
 *  hash  - hash map to iterate
 *  block - function to call
 *
 * Examples:
 *
 * Print each hash map key-value pair on separate line.
 * : h = ['test': 54, 'that': 42];
 * : forHash h do k v:
 * :    println "\(k): \(v)\n";
 * : done
 */
forHash h f is hash<'a, 'b> -> ('a -> 'b -> ()) -> () =
    // warning: it's also used as forMap implementation
   (i = (h unsafely_as ~Map)#entrySet()#iterator();
    i#hasNext() loop
       (e = i#next() unsafely_as ~java.util.Map$Entry;
        f (e#getKey() unsafely_as 'a) (e#getValue() unsafely_as 'b)));

/**
 * Returns a list [function(a), function(b), ...] for sequence [a, b, ...]
 * by applying the function to each element of the sequence (either
 * lazily or strictly).
 *
 * Arguments:
 *  function - function applied to the sequence elements
 *  sequence - list or array to be processed
 *
 * Description:
 * A lazy list is returned when applied on normal list. Full result
 * is not calculated in this case on application, but lazily as the
 * result is consumed by caller. Arrays and lists backed by arrays
 * are mapped strictly.
 *
 * You should ALWAYS use the strict map' instead, if the mapping function
 * has side effects, as it's not determined whether the function is applied
 * by map on some sequence element when map was called, some time later or
 * even never at all (if the result list was not consumed).
 */
map f l is ('a -> 'b) -> list?<'a> -> list<'b> =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#map(f) unsafely_as list<'b>
    fi;

/**
 * Returns strict list [function(a), function(b), ...] for sequence
 * [a, b, ...] by applying the function to each element of the sequence.
 *
 * Arguments:
 *  function - function applied to the sequence elements
 *  sequence - list or array to be processed
 *
 * Description:
 * It is similar to map function, but never creates a lazy list.
 * The map' is usually faster than map on lists, unless huge streams
 * are processed or most of the resulting list is not used. It works
 * identically to map on arrays.
 */
map' f l is ('a -> 'b) -> list?<'a> -> list<'b> =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#smap(f) unsafely_as list<'b>
    fi;

/**
 * Returns count of elements in collection.
 *
 * Arguments:
 *   collection - a list, array or hash map
 *
 * Description:
 * For list or array it's length is returned, and for hash map the number of
 * key-value pairs in that hash map. The length function can also be applied
 * to Java arrays (for example length new int[10]), as Yeti compiler wraps
 * these automatically into lists on function arguments.
 */
length l is map<'a, 'b> -> number =
    if nullptr? l then
        0
    else
        (l unsafely_as ~Coll)#length()
    fi;

/**
 * Access any value at runtime. Returns variant tagged with values
 * runtime type.
 *
 * The peekObject function may not be always accurate, as full type
 * information is not available at runtime (for example empty list is
 * indistinguishable from (), element types of empty collections
 * remain unknown and function types cannot be determined).
 *
 * Arguments:
 *   value - value to peek into
 */
peekObject object =
   (o = object as ~Object;
    if nullptr? o then
        List []
    elif o instanceof String then
        String (o unsafely_as string)
    elif o instanceof Num then
        Number (o unsafely_as number)
    elif o instanceof Boolean then
        Boolean (o unsafely_as boolean)
    elif o instanceof AList then
        List (map peekObject (o unsafely_as list<'a>))
    elif o instanceof ByKey then
        result = [:];
        i = (o unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            result.[peekObject (e#getKey() unsafely_as 'a)] :=
                peekObject (e#getValue() unsafely_as 'a));
        Hash result
    elif o instanceof Struct then
        st = o unsafely_as ~Struct;
        fields = map' (_ n = st#name(n)) [0 .. st#count() - 1];
        Struct {
            fields,
            value name =
                i = (fields unsafely_as ~AList)#index(name is string);
                if nullptr? i then
                    throw new NoSuchKeyException("No such field (\(name))")
                fi;
                peekObject (st#get(i) unsafely_as 'a)
        }
    elif o instanceof Tag then
        t = o unsafely_as ~Tag;
        Variant {tag = t#name, value = peekObject (t#value unsafely_as 'a)}
    else
        Object o
    fi);

plus a b = a + b;

{
    /**
     * Short-hand constant for None () value.
     */
    none = None (),

    /**
     * K combinator - returns constant function \x (which returns value
     * of the (first) argument x).
     *
     * Arguments:
     * x - value to be returned by resulting function (const x () is same as x).
     */
    const x = (_ = (); \x),

    /**
     * Application in reverse order. Expression (value |> function)
     * is equivalent to (function value).
     *
     * Arguments:
     * value - value given as argument to the function
     * function - function to apply
     *
     * Description:
     * The |> operator can be used to pipe value of expression through multiple
     * functions. Calls to |> are usually inlined into direct application by Yeti
     * compiler (if possible). Due to low priority (just above type operators is
     * and as) the parenthesis around function and argument expressions can be
     * omitted usually.
     *
     * Examples:
     * : a = iterate (+ 1) 0 |> take 5 |> map (*2);
     *
     * is same as:
     * : a = map (*2) (take 5 (iterate (+ 1) 0));
     *
     * both resulting with a = [0,2,4.6,8].
     */
    (|>) arg f = f arg,

    /**
     * Array/hash subscription operator collection.[key] as function.
     * Returns element at corresponding key (index).
     *
     * Arguments:
     * collection - array or hash table
     * key - array index or hash table key
     *
     * Exceptions:
     * NoSuchKey - if the key doesn't exist in the given collection
     *
     * Examples:
     * : numbers = [1: "one", 2: "two", 3: "three"];
     * : println (map (at numbers) [3, 1]); // ["three","one"]
     */
    at h k = h.[k],

    /**
     * Binary function composition. Composes binary f and
     * unary g so that arguments to f are transformed by applying g.
     *
     * Arguments:
     * f - binary function
     * g - unary function used to transform arguments to f
     *
     * Description:
     * : on f g x y = f (g x) (g y)
     *
     * Examples:
     * : list = [{name="X",v=6},{name="A",v=33}];
     * : sorted = sort (on (<) (.name)) list;
     *
     * The list is sorted by name structure field.
     */
    on f g is ('a -> 'a -> 'b) -> ('c -> 'a) -> 'c -> 'c -> 'b =
        new On(f, g) unsafely_as 'a, 

    /**
     * Logical negation of the value.
     *
     * Arguments:
     * value - logical value
     */
    norec (not) v = not v,

    /**
     * Logical conjunction of a and b.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (and) a b = a and b,

    /**
     * Logical disjunction of a or b.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (or) a b = a or b,

    /**
     * Checks whether a key exists in the hash map.
     *
     * Arguments:
     * key - key value to search for
     * hash - hash map to be checked
     *
     * Examples:
     * : h = ['a': 11, 'b': 22];
     * : printKey k =
     * :     if k in h then
     * :         println "h.[\(k)] = \(h.[k])"
     * :     else
     * :         println "\(k) doesn't exist"
     * :     fi;
     * : printKey 'b'; // prints h.[b] = 22
     * : printKey 'c'; // prints c doesn't exist
     */
    norec (in) a b = a in b,

    /**
     * Returns true when a and b values are equal (and false otherwise).
     *
     * It is internally implemented on most data types using .equals()
     * method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (==) a b = a == b,

    /**
     * Returns true when a and b values are not equal (and false otherwise).
     *
     * It is internally implemented on most data types using .equals()
     * method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (!=) a b = a != b,

    /**
     * Returns true when a value is less than b value (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (<)  a b = a <  b,

    /**
     * Returns true when a value is less than or equal to b value
     * (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (<=) a b = a <= b,

    /**
     * Returns true when a value is greater than b value (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (>)  a b = a >  b,

    /**
     * Returns true when a value is greater than or equal to b value
     * (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (>=) a b = a >= b,

    /**
     * Arithmetic sum of the values a and b.
     *
     * The result may not be accurate when applied to rational numbers
     * with very big numerator or denominator part as these overflow into
     * double-precision floating point numbers.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (+)      = plus,

    /**
     * Substracts subtrahend from minuend and returns the difference.
     *
     * The result may not be accurate when applied to rational numbers
     * with very big numerator or denominator part as these overflow into
     * double-precision floating point numbers.
     *
     * Arguments:
     * minuend    - number to substract from
     * subtrahend - number to substract
     */
    norec (-)  a b = a - b,

    /**
     * Arithmetic product of the values a and b.
     *
     * The result may not be accurate when applied to rational numbers
     * with very big numerator or denominator part as these overflow into
     * double-precision floating point numbers.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (*)  a b = a * b,

    /**
     * Divides dividend with divisor and returns the quotient.
     *
     * The result is rational number, when integer values fitting into
     * 32 bits are divided.
     *
     * The result may not be accurate when applied to big integers or
     * rational numbers with very big numerator or denominator part as
     * these overflow into double-precision floating point numbers.
     *
     * Arguments:
     * dividend - the number to divide
     * divisor  - dividend is divided by divisor
     */
    norec (/)  a b = a / b,

    /**
     * Remainder of division of the integer part of dividend
     * with integer part of divisor.
     *
     * Arguments:
     * dividend - the number to divide
     * divisor  - dividend is divided by divisor
     */
    norec (%)  a b = a % b,

    /**
     * Function composition - (f . g) x is same as f (g x).
     * Composes unary f and g into single function, where f is
     * applied to the result of application of g (to argument).
     *
     * Arguments:
     * f - first function
     * g - second function
     *
     * Examples:
     * : printLength = print . length;
     * : printLength [4,5,6]; // prints 3
     *
     * This is equivalent to:
     * : printLength x = print (length x);
     * : printLength [4,5,6]; // prints 3
     */
    norec (.)  a b = a . b,

    /**
     * Constructs a new list by prepending value to tail list.
     *
     * Arguments:
     * value - value to be prepended
     * list  - list used as tail of the constructed list
     *
     * Examples:
     * The following expressions result in equivalent lists.
     * : a :: [b, c] == [a, b, c]
     */
    norec (::) v l = v :: l,

    /**
     * Constructs a new list from head value and function that would return
     * the tail list. The function will be applied once, when the list
     * tail is requested for the first time. This allows creating lazy and
     * possibly infinite lists or streams.
     *
     * Arguments:
     * value    - value used as new list head
     * function - function that would return the list tail, when applied
     *            to unit value
     */
    norec (:.) v l = v :. l,

    /**
     * Returns true when regular expression has a match in the haystack string
     * (and false otherwise).
     *
     * Arguments:
     * haystack - string where to search the given regex match
     * regex    - string representing a regular expression
     *
     * Description:
     * The regular expression is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this operator
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * : if str =~ '\d' then
     * :     println "'\(str)' contains a number in it."
     * : fi
     */
    norec (=~) s p = s =~ p,

    /**
     * Returns true when regular expression has no match in the haystack string
     * (and false if it has).
     *
     * Arguments:
     * haystack - string where to search the given regex match
     * regex    - string representing a regular expression
     *
     * Description:
     *
     * This operator is negation of the =~ operator and could be defined in the
     * following way:
     * : (!~) haystack regex = not (haystack =~ regex)
     *
     * The regular expression is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this operator
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * : if str !~ '\d' then
     * :     println "'\(str)' has no number in it."
     * : fi
     */
    norec (!~) s p = s !~ p,

    /**
     * Divides integer part of dividend with integer part of divisor
     * and returns the integer part of quotient.
     *
     * Arguments:
     * dividend - the number to divide
     * divisor  - dividend is divided by integer part of divisor
     */
    norec (div) a b = a div b,

    /**
     * Shifts bit representation of integer part of the value
     * to left by given count of bits and returns the result.
     *
     * Arguments:
     * value - the value to shift
     * count - how much to shift
     */
    norec (shl) a b = a shl b,

    /**
     * Shifts bit representation of integer part of the value
     * to right by given count of bits and returns the result.
     *
     * Arguments:
     * value - the value to shift
     * count - how much to shift
     */
    norec (shr) a b = a shr b,

    /**
     * Returns bitwise XOR of integer parts of arguments a and b.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (xor) a b = a xor b,

    /**
     * Returns bitwise OR of integer parts of arguments a and b.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (b_or) a b = a b_or b,

    /**
     * Returns bitwise AND of integer parts of arguments a and b.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (b_and) a b = a b_and b,

    /**
     * Returns algebralic negation of argument value (negate value = -value).
     *
     * Arguments:
     * value - value to negate
     */
    norec negate a = negate a,

    /**
     * Check whether given value is a JVM null pointer, and returns true
     * when it is.
     *
     * Arguments:
     * value - value to check
     *
     * Notes:
     * Use defined? instead, unless you really know what you're doing.
     * The low-level check done by nullptr? may behave unexpectedly
     * together with some conversions done by Yeti compiler (for example
     * nullptr? (System#getenv('???')) is always false).
     */
    norec nullptr? a = nullptr? a,

    /**
     * Checks whether given value is defined, and returns true when it is.
     * Undefined values are JVM null pointer, undef_str and undef_bool.
     *
     * Arguments:
     * value - value to check
     *
     * Notes:
     * The unit value () is internally represented by JVM null pointer,
     * and therefore defined? () is false.
     *
     * Empty lists are often also considered to be undefined because
     * of being represented by null pointer (but empty arrays are not).
     * You should use empty? to detect empty lists.
     */
    norec defined? a = defined? a,

    /**
     * Checks whether a collection is empty, and returns true when it is.
     *
     * This function works on all kinds of standard collections - lists,
     * arrays and hashes implement the map<> interface.
     *
     * Arguments:
     * collection - collection to check
     */
    norec empty? a = empty? a,

    /**
     * Returns the first element of sequence (which must be non-empty).
     *
     * Arguments:
     * sequence - the list or array from which to extract the first element
     *
     * Exceptions:
     * java.lang.NullPointerException - when used on empty list
     * yeti.lang.EmptyArrayException  - when used on empty array
     */
    norec head a = head a,

    /**
     * Returns the tail of sequence consisting of all elements except
     * the first (head) one. Using tail is equivalent to using drop 1.
     *
     * Arguments:
     * sequence - the list or array to use
     *
     * Notes:
     * The tail function can be used on array. In this case a list view
     * of array is returned, consisting of all elements starting from
     * index 1 (subsequent applications of tail give views with increased
     * start index). As the list view still references to the original
     * array, it will change when the array is modified (use copy function
     * to get an independent copy).
     */
    norec tail a = tail a,

    /**
     * Identity check - returns true when a and b reference to the same
     * object instance (and false otherwise).
     *
     * Arguments:
     * a - first value reference
     * b - second value reference
     *
     * Notes:
     * It is equivalent to Java == operator (barring primitive values,
     * which don't exist in Yeti anyway).
     */
    norec same? a b = same? a b,

    /**
     * Iterates over sequence, applying the block function to the element
     * value for each sequence element.
     *
     * Arguments:
     *  sequence - list or array to iterate
     *  block    - function to call
     *
     * Examples:
     *
     * Print numbers from 1 to 100, using for on range list.
     * : for [1..100] do i:
     * :     println i
     * : done
     */
    norec for l f = for l f,

    /**
     * Acquires an intrinsic monitor lock on behalf of the executing thread,
     * applies the block to (), then releases the lock. It is equivalent to
     * executing the block in Java synchronized block.
     * 
     * Arguments:
     *  monitor - object that is used for the lock (value of any type can
     *            be use as long as nullptr? monitor is false)
     *  block   - function that is applied while the monitor lock is hold
     *
     * Exceptions:
     *  java.lang.NullPointerException - when monitor is a JVM null pointer
     *
     * Examples:
     * : var nameCount = 0;
     * : var lastName = '';
     * :
     * : addName name =
     * :     synchronized addName do:
     * :          lastName := name;
     * :          nameCount := nameCount + 1;
     * :     done;
     *
     * The addName function is used as a monitor here.
     */
    norec synchronized monitor block = synchronized monitor block,

    /**
     * Returns the result of concatenating strings a and b.
     *
     * Arguments:
     * a - first string
     * b - second string
     *
     * Notes:
     * Using this operator is equivalent to the embedded string expression
     * "\(a)\(b)" except for requiring the arguments to be of string type.
     */
    (^) a b is string -> string -> string = "\(a)\(b)",

    /**
     * Appends two sequences a and b lazily, returns the resulting list.
     *
     * Arguments:
     * a - first sequence (list or array)
     * b - second sequence (list or array)
     *
     * Description:
     * The list append operator creates a lazy list, which copies
     * the first sequence on the fly (as elements are requested),
     * and when it ends, gives the second sequence as the list tail.
     *
     * If first sequence (a) is an infinite list, then the result is
     * equivalent to it.
     *
     * If the second sequence (b) is an array, and is later mutated,
     * then the resulting list will see the modified array as its tail
     * (use copy function to get an independent copy).
     *
     * Examples:
     * : for ([1..4] ++ [13..15]) println;
     *
     * Prints numbers 1, 2, 3, 4, 13, 14, 15. No list containing those
     * numbers is never allocated (as lazy ranges are lazily appended).
     */
    (++) a b is list?<'a> -> list?<'a> -> list<'a> =
        if empty? a then
            b as ~Object unsafely_as 'a
        elif empty? b then
            a as ~Object unsafely_as 'a
        else
            new ConcatList(a, b) unsafely_as list<'a>
        fi,

    // damn struct polymorphism restriction. is it really needed?
    array, concat, fold, find, id, index, keys, hash, map, map',
    forHash, length, peekObject,

    /// Deprecated - it doesn't do anything useful, and if you want to
    /// wrap a Java array, then either use implicit cast or explicit
    /// value as array<'a> cast.
    wrapArray is 'a[] -> array<'a> = id,

    /**
     * Returns a list of elements obtained by applying the function
     * to each element of the Java collection.
     *
     * Arguments:
     *  function - function applied to list elements
     *  collection - java.util.Collection instance (may be null,
     *               empty list is returned in this case)
     */
    mapJavaList f l is (~Object -> 'a) -> ~java.util.Collection -> list<'a> =
        if nullptr? l then
            []
        else
            map f l#toArray()
        fi,

    /**
     * Iterates over Java map, calling the block function for each
     * map entry with key and value as arguments.
     *
     * Arguments:
     *  map   - java.util.Map instance to iterate
     *  block - function to call
     *
     * Examples:
     * : forJavaMap System#getProperties() do name value:
     * :    println {name, value}
     * : done
     * Prints system properties.
     */
    forJavaMap = forHash unsafely_as ~yeti.lang.Fun unsafely_as
        ~java.util.Map -> (~Object -> ~Object -> ()) -> (),

    /**
     * Gives values from collection as a list.
     *
     * Arguments:
     * collection - a list, array or hash map
     *
     * Description:
     * List is returned as is. A list view is returned for an array
     * (implementation wise just a type cast), so it will change when the
     * original array is modified. Differently from array, an independent
     * list consisting of values from the key-value pairs is created and
     * returned when the collection is a hash map.
     *
     * Either returned list or collection given as argument should be
     * explicitly copied (using copy function), if you want to store the
     * result for later usage and the original collection might change.
     *
     * Relying on the mutating list-view of an array is best
     * to be avoided - having direct reference to the original
     * collection is more straight-forward solution.
     */
    list a is map<'k, 'a> -> list<'a> =
        if empty? a then
            []
        else
            (a unsafely_as ~Coll)#asList() unsafely_as list<'a>
        fi,

    /**
     * Swaps two array/hash map element values stored at indexes i and j.
     *
     * Arguments:
     *  map - array or hash table
     *  i   - index/key
     *  j   - index/key
     *
     * Description:
     * The canonical implementation is following:
     * : swapAt map i j = 
     * :    (tmp = map.[i];
     * :     map.[i] := map.[j];
     * :     map.[j] := tmp);
     */
    swapAt a i j =
        x = a.[i];
        a.[i] := a.[j];
        a.[j] := x,

    /**
     * Applies function to two arguments in reverse order.
     * Useful for swapping binary functions arguments.
     *
     * Arguments:
     * function - function to apply
     * x        - second argument to give to the function
     * y        - first argument to give to the function
     *
     * Description:
     * : flip function x y = function y x;
     *
     * The result of applying flip to binary function is a function that takes
     * its two arguments in the reverse order of the original function.
     *
     * Examples:
     * The (>) operator could be defined in the terms of (<) using flip.
     * : (>) = flip (<);
     */
    flip f x y =
        f y x,

    /**
     * Memoizes the promise function with unit argument and returns the
     * memoized function.
     *
     * Arguments:
     * promise - a function taking () as argument, used as encapsulation
     *           of an expression
     *
     * Description:
     * The application of lazy results in memoized promise, which in essence
     * is a suspension of lazily evaluated expression. The evaluation can
     * be forced by applying this memoized promise to unit value (). The result
     * of evaluation is saved and returned, when it is forced and successfully
     * evaluated first time, and later applications of the memoized function
     * will return the saved result.
     *
     * If the evaluation fails to return a result, throwing an exception
     * instead, then subsequent attempt to force evaluation by applying the
     * memoized promise will cause a re-evaluation of the promise function
     * (by applying it again to the ()).
     *
     * Successful evaluation of the original promise may happen multiple times,
     * if done concurrently as a race in multiple threads.
     *
     * Examples:
     * : lazy_sum = lazy \(sum [1..100000000]);
     * : println (lazy_sum ());
     * : println (lazy_sum ());
     *
     * Here the sum of the large range will be calculated only on the first
     * application of lazy_sum. The second application returns the result
     * from first application.
     */
    lazy f is (() -> 'a) -> (() -> 'a) =
        new Lazy(f) unsafely_as (() -> 'a),

    /**
     * Constructs a pair structure containing arguments fst and snd as fields.
     *
     * Arguments:
     * fst - first field (fst) to the structure
     * snd - second field (snd) to the structure
     */
    pair fst snd =
        {fst, snd},

    /**
     * Gives string representation of value.
     *
     * Arguments:
     * value - value of any type
     *
     * Description:
     * String values are returned unmodified. Numbers are formatted into
     * decimal numbers. Rational and floating-point numbers are formatted
     * using Double#toString(), which uses dot as decimal separator and
     * uses scientific exponent notation for very small and big values,
     * like 1.3E20.
     *
     * Empty lists and the unit value can be internally represented by JVM
     * null pointer, which is shown as null. Empty arrays are always shown
     * as [].
     *
     * Lists, hash maps, structures and variant values are formatted using
     * Yeti syntax for them. The values of list/hash elements, structure
     * fields and variant tag parameters are formatted in the same style
     * recursively, with an exception for string values and null pointers.
     * String element/field values are formatted as double-quoted ("string")
     * Yeti string literals, and null pointers as [] (because empty list can
     * be internally a null pointer). Arrays are formatted exactly like lists.
     *
     * : string ()       // () is null pointer in runtime, result is "null"
     * : string {x = ()} // result is {x=[]}, as here () is a field value
     *
     * Following the Yeti syntax, lists have comma-separated values
     * surrounded by [] brackets, for example string list ["Hello", "World\n"].
     * Hash maps are similar, shown as a list of key: value pairs.
     * Structures are shown as comma-separated list of field=value bindings
     * surrounded by {} brackets, for example {a=33, s="something"}.
     *
     * The string representation is obtained by calling the Java
     * String#valueOf(value) method. The library implementation uses
     * string literal embedded expression:
     * : string value =
     * :     "\(value)";
     * This gets compiled down into the String#valueOf() call (as that
     * is used by compiler on all embedded string expressions unless
     * the expression type is already known to be string). The actual
     * formatting described above is done by #toString() methods in the
     * internal implementations of those data types.
     *
     * Examples:
     * num_strs = map string [1..10];
     *
     * Gets list of numbers 1 to 10 as strings.
     */
    string x =
        "\(x)",

    /**
     * Converts the given string into a number and returns the result.
     *
     * Arguments:
     *  string - a string to parse as a number
     *
     * Description:
     * The string argument must be in one of the following formats:
     *
     * 1. Decimal integer of arbitrary size. The result will be
     *    integer number, values not fitting into 64-bit signed integer
     *    are internally stored using the BigInteger class.
     *
     * 2. Octal integer of arbitrary size with "0o" or "0O" as prefix.
     *    The result will be integer number.
     *
     * 3. Hexadecimal integer of arbitrary size with "0x" or "0X" as prefix.
     *    The result will be integer number.
     *
     * 4. Decimal number with fractional part after dot (for example 17.52).
     *    The result will rational number, if both numerator and denominator
     *    parts of decimal fraction can be expressed as 32-bit signed integers
     *    (exact value). Otherwise the result will be double-precision
     *    floating-point number (possibly inexact value).
     *
     * 5. Decimal number with exponent after 'e' or 'E' (for example 1.23e-3).
     *    Optional fractional part is separated with dot.
     *    The result will be double-precision floating-point number.
     *
     * 6. Decimal number with optional fractional part after dot and 'e' or
     *    'E' at the end (for example 1e). The result will be double-precision
     *    floating-point number. This can be used to force creating a
     *    floating-point number instead of rational or integer number.
     *
     * This set of formats is identical to the format of numeric literals
     * in the Yeti source code. Preceding and trailing whitespace characters
     * are removed before parsing.
     *
     * Exceptions:
     * java.lang.NumberFormatException - when the argument string is not in
     *                                   a recognized numeric format
     */
    number x =
        Core#parseNum(x is string unsafely_as ~String),

    /**
     * Returns the smaller of the two ordered values a and b (the ordering is
     * as defined by the (<) operator). The result is unspecified if one of
     * the argument values is floating-point number NaN.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    min a b =
        if a < b then a else b fi,

    /**
     * Returns the greater of the two ordered values a and b (the ordering is
     * as defined by the (<) operator). The result is unspecified if one of
     * the argument values is NaN.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    max a b =
        if a > b then a else b fi,

    /**
     * Returns the absolute value of the given numeric value.
     *
     * Arguments:
     * value - a numeric value
     */
    abs a =
        if a < 0 then -a else a fi,

    /**
     * Returns the arithmetic sum of a finite sequence of numbers.
     * Zero is returned for an empty sequence.
     *
     * Arguments:
     * sequence - list or array of numbers
     *
     * Description:
     * : sum = fold (+) 0;
     *
     * For example, sum [1, 2, 3] is computed as 0 + 1 + 2 + 3.
     */
    sum l =
        fold plus 0 l,

    /**
     * Maps a function over the sequence and concatenates the results.
     * Shorthand for (concat . map function).
     *
     * Arguments:
     *  function - function applied to the sequence elements
     *  sequence - list or array to be processed
     */
    concatMap f l is ('a -> list?<'b>) -> list?<'a> -> list<'b> =
        if empty? l then
            []
        else
            concat ((l unsafely_as ~AList)#map(f) unsafely_as list<'a>)
        fi,

    /**
     * Returns true if and only if there exists a sequence element, for which
     * the predicate function returns true. A false value is returned otherwise
     * (empty sequence or predicate is false for all sequence elements).
     *
     * Arguments:
     * predicate - function that returns true or false for list element
     * sequence  - list or array to be scanned
     */
    any f l =
        not nullptr? (find f l),

    /**
     * Returns true, if the predicate function returns true for
     * all elements of the given sequence or the sequence is empty.
     * The false value is returned otherwise (predicate is false
     * for one or more sequence elements).
     *
     * Arguments:
     * predicate - function that returns true or false for list element
     * sequence  - list or array to be scanned
     */
    all f l =
        nullptr? (find (_ x = not f x) l),

    /**
     * Returns first element of the sequence, for which the predicate
     * returns false, or the last element, when the predicate is
     * true for all elements of the sequence.
     *
     * Arguments:
     * predicate - function that returns true for elements to avoid
     * sequence  - sequence of values (array or list)
     *
     * Exceptions:
     * java.lang.IllegalArgumentException - if the given sequence is empty
     *
     * Examples:
     * : avoid (== '') [userOpt, systemOpt, defaultOpt]
     */
    avoid f l is ('a -> boolean) -> list?<'a> -> 'a =
        if empty? l then
            throw new IllegalArgumentException("avoid: empty list")
        fi;
        var i = l unsafely_as ~AIter;
        var value = () as ~Object;
        (value := i#first();
         i := i#next();
         not nullptr? i and f (value unsafely_as 'a)) loop;
        value unsafely_as 'a,

    /**
     * Returns true if and only if the sequence contains element equal
     * to the given value. If there is no such element, false is returned.
     * Equality is checked as defined by the (==) operator.
     *
     * Arguments:
     * value    - value to search from the sequence
     * sequence - list or array to be searched
     */
    contains? v l is 'a -> list?<'a> -> boolean =
        not (nullptr? l or nullptr? (l unsafely_as ~AList)#index(v)),

    /**
     * Returns the default value, when the option is None _, and
     * result of applying the function to the Some parameter value,
     * when the option is Some value.
     *
     * Arguments:
     * default  - value to return, when the option argument is None _
     * function - function to apply to value,
     *            when the option argument is Some value
     * option   - a variant Some value | None _
     */
    maybe default f =
       \case of
        Some v: f v;
        None _: default;
        esac,

    /**
     * Splits a given sequence into two parts, putting elements from the start
     * of the sequence into fst as long as the predicate function is false
     * for a given element. The rest of the sequence is returned as snd field.
     *
     * Arguments:
     * predicate - predicate function 
     * sequence  - a list or array to split
     */
    splitBy pred seq is ('a -> boolean) -> list?<'a>
                          -> { fst is list<'a>, snd is list<'a> } = 
        a = new MList();
        var l = seq unsafely_as ~AList unsafely_as list<'a>;
        // over-optimized loop from hell. don't code like that.
        not empty? l and (h = head l; not pred h and (a#add(h); true)) loop
            l := tail l;
        { /// Elements from start of the sequence that
          /// do not satisfy the predicate.
          fst = if a#isEmpty() then [] else a unsafely_as list<'a> fi,
          /// Reminder of the sequence.
          snd = l },

    /**
     * Splits a given sequence into two parts, returning first n elements
     * as fst and the rest as snd field. Full sequence is returned as list
     * in the fst field, if n is equal or greater than the length of the
     * sequence (and snd will be empty list in this case).
     *
     * Arguments:
     * n        - position of the split
     * sequence - list or array to split
     *
     * Description:
     * : splitAt n sequence = {
     * :     fst = take n sequence,
     * :     snd = drop n sequence
     * : }
     */
    splitAt n seq is number -> list?<'a>
                      -> { fst is list<'a>, snd is list<'a> } =
        a = new MList();
        var l = seq unsafely_as ~AList unsafely_as list<'a>;
        var n = n;
        if n < 256 then
            a#reserve(n)
        fi;
        n > 0 and not empty? l loop
           (a#add(head l);
            l := tail l;
            n := n - 1);
        { /// The sequence prefix of length n.
          fst = if a#isEmpty() then [] else a unsafely_as list<'a> fi,
          /// Elements of the sequence starting from the nth element.
          snd = l },

    /**
     * Returns first n elements of the sequence as a lazy list. All elements
     * are returned, if n is equal or greater than the length of the sequence.
     *
     * Arguments:
     * n        - how many elements to take
     * sequence - initial list or array
     *
     * Notes:
     * The given sequence is lazily consumed as the result returned by take
     * is consumed. If the sequence is a mutable array, and modified after
     * appling the take function, the result of application is undefined.
     */
    take n l is number -> list?<'a> -> list<'a> =
        if nullptr? l then
            []
        else
            TakeList#take(l, n) unsafely_as list<'a>
        fi,

    /**
     * Returns the suffix of the sequence (as list) omitting first n
     * sequence elements. An empty list is returned, if n is equal or
     * greater than the length of the sequence.
     *
     * Arguments:
     * n        - how many elements to drop from the start of the sequence
     * sequence - initial list or array
     *
     * Notes:
     * The suffix is returned without copying it. When the drop function
     * is used on an array, a list view of the array is returned, consisting
     * of all elements starting from index n. As the list view still references
     * to the original array, it will change when the array is modified (use
     * copy function to get an independent copy).
     */
    drop n l =
        if n <= 0 then
            l
        elif empty? l then
            []
        else
            drop (n - 1) (tail l)
        fi,

    /**
     * Returns a lazy list containing longest prefix of the sequence,
     * where the predicate function is true for all elements.
     *
     * Arguments:
     * predicate - function used to check the sequence elements
     * sequence  - list or array to use
     *
     * Notes:
     * The given sequence is lazily consumed as the result returned by
     * takeWhile is consumed. If the sequence is a mutable array, and
     * modified after appling the takeWhile function, the result of
     * application is undefined.
     */
    takeWhile pred l is ('a -> boolean) -> list?<'a> -> list<'a> =
        if empty? l then
            []
        else
            TakeWhile#take(l, pred) unsafely_as list<'a>
        fi,

    /**
     * Returns an infinite lazy list, where each following element is result
     * of appling the function to the value of the element before it. The
     * first element value is given.
     *
     * Arguments:
     * first    - value of the first element in the returned list
     * function - function to apply to derive the next element value
     *
     * Examples:
     * The result of iterate f x is the following infinite list:
     * : [x, f x, f (f x), f (f (f x)), ...]
     *
     * If addition is used as the function, the result is incrementing sequence:
     * : take 10 (iterate (+1) 0) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     */
    iterate f x is ('a -> 'a) -> 'a -> list<'a> =
        new Iterate(x, f) unsafely_as list<'a>,

    /**
     * Returns non-duplicate elements of the sequence as a list.
     * This means that no element in the returned list is equal to
     * some other element (as defined by ==) in this list.
     * The original ordering of the sequence is not preserved.
     *
     * Arguments:
     * sequence - list or array to be processed
     */
    nub is list?<'a> -> list<'a> =
        keys . hash,

    /**
     * Returns a list of lists, where each sublist contains only equal elements,
     * and the concatenation of the result is equal to the original sequence.
     * Elements are considered equal, when the given predicate function
     * is true for them.
     *
     * Arguments:
     * predicate - function that returns true for values considered equal
     * sequence  - list or array to be processed
     *
     * Examples:
     * : groupBy (==) [1,1,0,2,0,0,0,3] == [[1,1],[0],[2],[0,0,0],[3]]
     */
    groupBy eq l is ('a -> 'a -> boolean) -> list?<'a> -> list<list<'a>> =
        if empty? l then
            []
        else // this is an example of over-optimisation ;)
            var result = new MList();
            var collector = new MList();
            var i = l unsafely_as ~AIter;
            var prev = i#first();
            collector#add(prev);
            (i := i#next(); not nullptr? i) loop
               (val = i#first();
                if not ((val unsafely_as 'a) `eq` (prev unsafely_as 'a)) then
                    result#add(collector);
                    collector := new MList()
                fi;
                prev := val;
                collector#add(val));
            result#add(collector);
            result unsafely_as 'l
        fi,

    /**
     * Returns as list the sequence sorted in ascending order according
     * to the order defined by the (<) comparision operator.
     *
     * Arguments:
     * sequence - list or array to be sorted (not modified by sort function)
     *
     * Description:
     * The original sequence is copied and sorted using
     * java.util.Arrays#sort(Object[]) method. The sequence elements
     * are required to be of ordered type (^a). The result should be similar
     * to using sortBy (<), although the sort function works usually faster.
     *
     * Examples:
     * sort [3,1,4,1,5,9,2,6,5,3] == [1,1,2,3,3,4,5,5,6,9]
     */
    sort l is list?<^a> -> list<^a> =
        if empty? l then
            []
        else
            (l unsafely_as ~AList)#sort() unsafely_as list<^a>
        fi,

    /**
     * Returns as list the sequence sorted according to the compare function.
     * The returned list will be ordered in such manner, that compare x y
     * returns false for any list elements x and y, where y is before x.
     * The behaviour of sortBy is undefined, if the compare function doesn't
     * define total ordering.
     *
     * Arguments:
     * compare  - function to compare two elements ((<) gives ascending order)
     * sequence - list or array to be sorted (not modified by sortBy function)
     *
     * Examples:
     * sortBy (<) [3,1,4,1,5,9,2,6,5,3] == [1,1,2,3,3,4,5,5,6,9]
     *
     * Notes:
     * Current implementation uses merge sort algorithm.
     * Stable sorting is not guaranteed.
     */
    sortBy less? l is ('a -> 'a -> boolean) -> list?<'a> -> list<'a> =
        if empty? l then
            []
        else
            (l unsafely_as ~AList)#sort(less?) unsafely_as list<'a>
        fi,

    /// Mathematical constant pi (nearest value to pi expressable
    /// as double precision floating point number).
    pi = Math#PI,

    /**
     * Returns natural logaritm (base e) of the given value.
     * Implemented using Math#log(value).
     *
     * Arguments:
     * value - a positive number (NaN is returned for negative values)
     */
    ln a = Math#log(a),

    /**
     * Returns constant e raised to the given power.
     * Implemented using Math#exp(power).
     *
     * Arguments:
     * power - a numeric value
     */
    exp a = Math#exp(a),

    /**
     * Returns the trigonometric cosine of the given angle.
     * Implemented using Math#cos(angle).
     *
     * Arguments:
     * angle - an angle in radians
     */
    cos a = Math#cos(a),

    /**
     * Returns the trigonometric sine of the given angle.
     * Implemented using Math#sin(angle).
     *
     * Arguments:
     * angle - an angle in radians
     */
    sin a = Math#sin(a),

    /**
     * Returns the trigonometric tangent of the given angle.
     * Implemented using Math#tan(angle).
     *
     * Arguments:
     * angle - an angle in radians
     */
    tan a = Math#tan(a),

    /**
     * Returns the arc cosine of the given value in radians.
     * The returned angle is in the range 0.0..pi.
     * Implemented using Math#acos(value).
     *
     * Arguments:
     * value - a numeric value
     */
    acos a = Math#acos(a),

    /**
     * Returns the arc sine of the given value in radians.
     * The returned angle is in the range -pi/2..pi/2.
     * Implemented using Math#asin(value).
     *
     * Arguments:
     * value - a numeric value
     */
    asin a = Math#asin(a),

    /**
     * Returns the arc tangent of the given value in radians.
     * The returned angle is in the range -pi/2..pi/2.
     * Implemented using Math#atan(value).
     *
     * Arguments:
     * value - a numeric value
     */
    atan a = Math#atan(a),

    /**
     * Returns the positive square root of the given value.
     * Implemented using Math#sqrt(value).
     *
     * Arguments:
     * value - a positive number or zero (NaN is returned for negative values)
     */
    sqrt a = Math#sqrt(a),

    /**
     * Returns the integer part of the given value.
     *
     * Arguments:
     * value - a numeric value
     *
     * Notes:
     * Current implementation expects that result fits into
     * 64-bit signed integer (Long#MIN_VALUE..Long#MAX_VALUE).
     */
    int a is number -> number = (a as ~java.lang.Number)#longValue(),

    /**
     * Returns a copy of the string, with all occurences of the needle
     * substring replaced with replacement string in the given haystack string.
     *
     * Description:
     * The needle and replacement strings are treated as literal substring,
     * with no metacharacters. All strings represent UTF-16 code unit sequences
     * (internally java.lang.String instances). All occurences of the needle
     * subsequence starting from beginning of the string are replaced
     * sequentially and the resulting string is returned.
     *
     * Arguments:
     * needle      - a string to search
     * replacement - a string to use as replacement
     * haystack    - a original string to process
     *
     * Examples:
     * strReplace 'aba' '+' 'xabaabababax' == 'x++b+x' 
     */
    strReplace needle replacement haystack
            is string -> string -> string -> string =
        Core#replace(needle unsafely_as ~String,
                     replacement unsafely_as ~String,
                     haystack unsafely_as ~String),

    /**
     * Returns the length (number of UTF-16 code units) of string.
     *
     * Arguments:
     * string - an UTF-16 encoded string (internally stored as java.lang.String)
     *
     * Notes:
     * The basic multilingual (first) plane of unicode characters are
     * represented as single code units in UTF-16, therefore strLength returns
     * the count of unicode characters for strings containing only those
     * characters. The java.lang.String length method works in the same way,
     * and compiler optimizes strLength applications into String#length() calls.
     */
    norec strLength s = strLength s,

    /**
     * Returns a copy of the string, with all lowercase letters translated
     * to uppercase using the rules of the default locale.
     *
     * Arguments:
     * string - a string value (internally stored as java.lang.String)
     *
     * Notes:
     * Compiler optimizes strUpper applications into String#toUpperCase() calls.
     */
    norec strUpper s = strUpper s,

    /**
     * Returns a copy of the string, with all lowercase letters translated
     * to uppercase using the rules of the default locale.
     *
     * Arguments:
     * string - a string value (internally stored as java.lang.String)
     *
     * Notes:
     * Compiler optimizes strLower applications into String#toLowerCase() calls.
     */
    norec strLower s = strLower s,

    /**
     * Returns a copy of the string, with leading and trailing whitespace
     * removed.
     *
     * Arguments:
     * string - a string value (internally stored as java.lang.String)
     *
     * Notes:
     * Compiler optimizes strTrim applications into String#trim() calls.
     * The argument instance is directly returned, if there is no whitespace
     * to remove.
     */
    norec strTrim s = strTrim s,

    /**
     * Returns the substring of given string, from code unit at start index
     * until code unit at end index. The start and end indexes are 0-based.
     *
     * Arguments:
     * string - an UTF-16 encoded string (internally stored as java.lang.String)
     * start  - index of the code unit starting returned slice (inclusive)
     * end    - index of the code unit ending returned slice (exclusive)
     *
     * Exceptions:
     * IndexOutOfBoundsException - if start or end index is negative or > to
     *                             the length of string, or start index is
     *                             is greater than the end index
     *
     * Notes:
     * The basic multilingual (first) plane of unicode characters are
     * represented as single code units in UTF-16.
     * Compiler optimises strSlice applications into String#substring() calls.
     */
    norec strSlice s start end = strSlice s start end,

    /**
     * Returns the substring of given string, from code unit at start index
     * until to the end of string.
     * Same as strSlice string start (strLength string).
     *
     * Arguments:
     * string - an UTF-16 encoded string (internally stored as java.lang.String)
     * start  - 0-based index of the code unit starting returned slice
     *          (inclusive)
     *
     * Exceptions:
     * IndexOutOfBoundsException - if the start index is negative or greater
     *                             than the length of string
     *
     * Notes:
     * The basic multilingual (first) plane of unicode characters are
     * represented as single code units in UTF-16.
     * Compiler optimises strRight applications into String#substring() calls.
     */
    norec strRight s pos = strRight s pos,

    /**
     * Returns true when the given string starts with the specified prefix
     * (and false otherwise).
     *
     * Arguments:
     * string - a string value to test
     * prefix - the expected prefix string for the tested string value
     *
     * Notes:
     * Compiler optimises strStarts? applications into
     * String#startsWith() calls.
     */
    norec strStarts? s start = strStarts? s start,

    /**
     * Returns true when the given string ends with the specified suffix
     * (and false otherwise).
     *
     * Arguments:
     * string - a string value to test
     * suffix - the expected prefix suffix for the tested string value
     *
     * Notes:
     * Compiler optimises strEnds? applications into String#endsWith() calls.
     */
    norec strEnds? s end = strEnds? s end,

    /**
     * Finds the start position of the first occurrence of the substring in
     * the given string, that is not before the from index.
     *
     * Arguments:
     * string    - the string to be searched
     * substring - the substring to search
     * from      - the search starts from this index
     *
     * Exceptions:
     * IndexOutOfBoundsException - if the from index is negative or greater
     *                             than the length of string
     *
     * Notes:
     * The strings are UTF-16 encoded code unit sequences (internally stored as
     * java.lang.String) with 0-based indexing. Compiler optimises
     * strIndexOf applications into String#indexOf() calls.
     */
    norec strIndexOf haystack needle from = strIndexOf haystack needle from,

    /**
     * Finds the start position of the last occurrence of the substring in
     * the given string, that is not after the from index.
     *
     * Arguments:
     * string    - the string to be searched
     * substring - the substring to search
     * from      - the search starts from this index
     *
     * Exceptions:
     * IndexOutOfBoundsException - if the from index is negative or greater
     *                             than the length of string
     *
     * Notes:
     * The strings are UTF-16 encoded code unit sequences (internally stored as
     * java.lang.String) with 0-based indexing. Compiler optimises
     * strLastIndexOf applications into String#lastIndexOf() calls.
     */
    norec strLastIndexOf haystack needle from =
            strLastIndexOf haystack needle from,

    /**
     * Finds the start position of the last occurrence of the substring in
     * the given string.
     * Same as strLastIndexOf string substring (strLength string).
     *
     * Arguments:
     * string    - the string to be searched
     * substring - the substring to search
     *
     * Notes:
     * The strings are UTF-16 encoded code unit sequences (internally stored as
     * java.lang.String) with 0-based indexing, and compiler optimises
     * strLastIndexOf applications into String#lastIndexOf() calls.
     */
    norec strLastIndexOf' haystack needle = strLastIndexOf haystack needle,

    /**
     * Splits the string into substrings separated by matches of the regex,
     * and returns array of the resulting substrings.
     *
     * Arguments:
     * regex  - string representing a regular expression
     * string - string to split
     *
     * Description:
     * The matches of the regex are used as delimiters, and the substrings
     * not matching the regex are returned in array in the order they were
     * in the initial string. Empty substrings before matches are included
     * in the returned array. Matches at the end of the given string won't
     * add empty strings to the result.
     *
     * The regex is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this function
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * : strSplit ';' ';a;foo;;;bar;;' == ["","a","foo","","","bar"]
     */
    norec strSplit re = strSplit re,

    /**
     * Returns a copy of the string, with each substring matching the regex
     * substituded with the replacement string in the given haystack string.
     *
     * Arguments:
     * regex       - string representing a regular expression
     * replacement - a string to use as replacement
     * haystack    - a original string to process
     *
     * Description:
     * Matches of the given regex are searched sequentially from the beginning
     * of haystack string and replaced with the given replacement string.
     *
     * The replacement string can contain dollar signs ($) followed by decimal
     * number (like $1, $2 etc), these will be replaced with text matched by
     * corresponding group in the regex. $0 will be replaced with whole
     * matched substring. Backslashes in replacement string escape the
     * following code unit as a literal code unit (all occurrences of $ and
     * \ meant to be literal symbols must be escaped this way).
     *
     * The regex is compiled and matched using the java.util.regex
     * implementation (Matcher#replaceAll() is used for substitution), and
     * therefore uses the same (Perl regular expression compatible) syntax.
     * Yeti compiler optimises usage of this function when literal string is
     * used as regex argument, so that the regex will be compiled only once
     * into the java.util.regex.Pattern instance. All strings represent
     * UTF-16 code unit sequences (internally java.lang.String instances).
     *
     * Examples:
     * : substAll 'a(b*)' '$1' 'an abacus' == 'n bcus'
     */
    norec substAll re = substAll re,

    /**
     * Generates a lazy list by searching matches of given regex in the string.
     *
     * Arguments:
     * regex   - string representation of regular expression
     * onMatch - function to apply to the captured groups from matches
     * onText  - function to apply to the non-matching substrings
     * string  - string where to search the given regex matches
     *
     * Description:
     * When a match is found, the onText function is applied to the text
     * between previous match (or start of the string for first match) and
     * matched substring, if this text isn't zero-length. The onMatch
     * function is applied to an array composed of captured groups in the
     * regex (implicit capture of whole matched substring is given as 0th
     * element in the capture group array). The onText function is also
     * applied to the end of the string after last match found, if the last
     * match ends before.
     *
     * The results of onText and onMatch applications are added to the
     * resulting list in the same order as the corresponding substrings were
     * in the processed string. This regex match searching and list
     * construction is done lazily, as the returned list is consumed
     * (so if you apply matchAll to long string containing many matches of
     * the substring and use only head of the result, only the first match
     * will be actually searched).
     *
     * The regex is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this function
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * : for (matchAll '\d+' M T '2012-08-23T04:11Z') println;
     *
     * Prints the following parts of this ISO 8601 date by matching
     * number sequences:
     * : M ["2012"]
     * : T "-"
     * : M ["08"]
     * : T "-"
     * : M ["23"]
     * : T "T"
     * : M ["04"]
     * : T ":"
     * : M ["11"]
     * : T "Z"
     */
    norec matchAll re = matchAll re,

    /**
     * Returns a function that searches for a regex match in the given string.
     *
     * Arguments:
     * regex  - string representing a regular expression
     * string - string where to search the given regex match
     *
     * Description:
     * The returned function attempts to find next substring that matches the
     * regex pattern, when applied to the unit value (). It returns array of
     * captured groups from the regex match (including the whole matched substring
     * as zeroth array element), or empty array, if no match could be found.
     *
     * The regular expression is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this function
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * Repeated application of the returned function can be used to find all
     * substrings matching the regex pattern in the given string:
     * : printMatches matcher =
     * :    (match = matcher ();
     * :     if not empty? match then
     * :         println match.[0];
     * :         printMatches matcher;
     * :     fi);
     * : printMatches (like '\d+' '2012-08-23T04:11Z');
     *
     * This will print all numbers from the ISO 8601 date:
     * : 2012
     * : 08
     * : 23
     * : 04
     * : 11
     *
     * The matches could be collected into list using the collect function:
     * : matches = collect (like '\d+' '2012-08-23T04:11Z') () empty?);
     * : println matches; // [["2012"], ["08"], ["23"], ["04"], ["11"]]
     *
     * The returned function can be applied right away,
     * if only first match is needed:
     * : date = '2012-08-23T04:11Z';
     * : case like '(\d+):(\d+)' date () of
     * : [_, hour, min]: println "Hour: \(hour), minutes: \(min)";
     * : _: println "No time found in the date string.";
     * : esac;
     */
    norec like re = like re,

    /**
     * Returns one UTF-16 code unit (Java char) from the string at the given
     * index.
     *
     * Arguments:
     * string - an UTF-16 encoded string (internally stored as java.lang.String)
     * index  - a 0-based index of the code unit
     *
     * Exceptions:
     * IndexOutOfBoundsException - if the index is negative or >= to the length
     *                             of string
     */
    norec strChar s pos = strChar s pos,

    /**
     * Returns the substring of given string, from the start of string
     * until code unit at end index. Same as strSlice string 0 end.
     *
     * Arguments:
     * string - an UTF-16 encoded string (internally stored as java.lang.String)
     * end    - 0-based index of the code unit ending returned slice (exclusive)
     *
     * Notes:
     * The basic multilingual (first) plane of unicode characters are
     * represented as single code units in UTF-16.
     *
     * Exceptions:
     * IndexOutOfBoundsException - if the end index is negative or greater
     *                             than the length of string
     */
    strLeft s end = strSlice s 0 end,

    /**
     * Returns the string prefix until the start of first occurrence of the
     * specified substring in the given string (or undef_str, if the substring
     * isn't part of the given string).
     *
     * Arguments:
     * string    - the string to be searched
     * substring - the substring to search
     *
     * Examples:
     * : strLeftOf 'at' 'potatos' == 'pot'
     */
    strLeftOf subString s is string -> string -> string =
        i = strIndexOf s subString 0;
        if i < 0 then undef_str else strSlice s 0 i fi,

    /**
     * Returns the string suffix starting from the end of last occurrence of
     * the specified substring in the given string (or undef_str, if the
     * substring isn't part of the given string).
     *
     * Arguments:
     * string    - the string to be searched
     * substring - the substring to search
     *
     * Examples:
     * : strRightOf 'at' 'potatos' == 'os'
     */
    strRightOf subString s is string -> string -> string =
        i = strLastIndexOf' s subString;
        if i < 0 then undef_str else strRight s (i + strLength subString) fi,

    /**
     * Joins string representations of list elements into a single string,
     * with separator string insterted between each list element.
     * The resulting string is returned.
     *
     * Arguments:
     * separator - a string to be inserted between list elements
     * list      - a list to be joined
     *
     * Examples:
     * : strJoin '; ' [1..5] == '1; 2; 3; 4; 5'
     *
     * Notes:
     * The string representations of list elements are idententical to those
     * that would be returned by the string function.
     * : strJoin separator (map string list) == strJoin separator list
     */
    strJoin sep list is string -> list?<'a> -> string =
        if empty? list then
            ""
        else
            // use unsafely_as to not give null's for undef_str's
            buf = new java.lang.StringBuffer(
                        "\(head list)" unsafely_as ~String);
            var l = tail list;
            if sep == '' then
                not nullptr? l loop
                   (buf#append(head l as ~Object);
                    l := tail l)
            else
                not nullptr? l loop
                   (buf#append(sep unsafely_as ~String);
                    buf#append(head l as ~Object);
                    l := tail l)
            fi;
            buf#toString()
        fi,

    /**
     * Returns string with padding added at the end, if the string length
     * is shorter than the desired length. The padding is added as many times
     * as required (but not more) to get result with length that is not
     * shorter from the requested one. The original string is returned
     * unmodified, if its length is greater or equal to the requested one.
     *
     * Arguments:
     * padding - a padding string to append
     * string  - a string to be padded
     * length  - desired result length
     *
     * Examples:
     * : strPad '.' 10 'test' == 'test......'
     */
    strPad pad n str is string -> number -> string -> string =
        if strLength str >= n then
            str
        else
            buf = new java.lang.StringBuffer(str unsafely_as ~String);
            buf#length() < n loop buf#append(pad unsafely_as ~String);
            buf#toString()
        fi,

    /**
     * Returns a copy of the string, with first character translated to
     * uppercase. The string is returned unmodified, if this is not possible.
     *
     * Arguments:
     * string - a string value
     */
    strCapitalize str is string -> string =
        Core#capitalize(str unsafely_as ~String),

    /**
     * Returns a copy of the string, with first character translated to
     * lowercase. The string is returned unmodified, if this is not possible.
     *
     * Arguments:
     * string - a string value
     */
    strUncapitalize str is string -> string =
        Core#uncapitalize(str unsafely_as ~String),

    mapHash f h is ('a -> 'b -> 'c) -> hash<'a, 'b> -> list?<'c> =
        a = new MList();
        a#reserve((h unsafely_as ~Map)#size());
        i = (h unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            a#add(f (e#getKey() unsafely_as 'a)
                    (e#getValue() unsafely_as 'b)));
        a unsafely_as list?<'c>,

    identityHash () is () -> hash<'a, 'b> =
        new IdentityHash() unsafely_as hash<'a, 'b>,

    copy h is 'a -> 'a =
        if nullptr? h then
            () as ~Object unsafely_as 'a
        else
            (h is map<'a, 'b> unsafely_as ~Coll)#copy() unsafely_as map<'a, 'b>
        fi,

    /**
     * Fail evaluation with given error message by throwing FailureException.
     *
     * Arguments:
     *  message - error message used as exception description
     *
     * Exceptions:
     *  FailureException - always.
     */
    failWith message =
        throw new FailureException(message),

    delete h k is map<'a, 'b> -> 'a -> () =
        _ = (h unsafely_as ~ByKey)#remove(k),

    deleteAll h ks is map<'a, 'b> -> list?<'a> -> () =
        _ = (h unsafely_as ~Coll)#removeAll(ks),

    setHashDefault h f is hash<'a, 'b> -> ('a -> 'b) -> () =
        (h unsafely_as ~ByKey)#setDefault(f),

    clearHash h is hash<'a, 'b> -> () =
        (h unsafely_as ~Map)#clear(),

    insertHash h h' is hash<'a, 'b> -> hash<'a, 'b> -> () =
        _ = (h unsafely_as ~Map)#putAll(h' unsafely_as ~Map),

    setArrayCapacity a n is array<'a> -> number -> () =
        (a unsafely_as ~MList)#reserve(n),

    clearArray a is array<'a> -> () =
        (a unsafely_as ~MList)#clear(),

    shift a is array<'a> -> 'a =
        (a unsafely_as ~MList)#shift() unsafely_as 'a,

    pop a is array<'a> -> 'a =
        (a unsafely_as ~MList)#pop() unsafely_as 'a,

    push a v is array<'a> -> 'a -> () =
        (a unsafely_as ~MList)#add(v),

    slice a start end is array<'a> -> number -> number -> array<'a> =
        (a unsafely_as ~MList)#copy(start, end) unsafely_as array<'a>,

    collect f a endPred is ('a -> 'b) -> 'a -> ('b -> boolean) -> list<'b> =
       (l = new MList();
        (v = f a; not endPred v and (l#add(v); true)) loop;
        if l#isEmpty() then
            []
        else
            l unsafely_as list<'a>
        fi),

    filter f l is ('a -> boolean) -> list?<'a> -> list<'a> =
        if empty? l then
            []
        else
            FilterList#filter(l, f) unsafely_as list<'a>
        fi,

    catSome l is list?<Some 'a | None 'b> -> list<'a> =
        if empty? l then
            []
        else
            CatSomes#filter(l) unsafely_as list<'a>
        fi,

    map2 f a b is ('a -> 'b -> 'c) -> list?<'a> -> list?<'b> -> list<'c> =
        if empty? a or empty? b then
            []
        else
            new Map2List(f, a, b) unsafely_as list<'c>
        fi,

    revAppend a b is list?<'a> -> list<'a> -> list<'a> =
        if empty? a then
            b
        else
            var a = a unsafely_as ~AIter;
            var res = b;
            not nullptr? a loop
               (res := (a#first() unsafely_as 'a) :: res;
                a := a#next());
            res
        fi,

    reverse l is list?<'a> -> list<'a> =
        if nullptr? l then
            []
        else
            (l unsafely_as ~AList)#reverse() unsafely_as list<'a>
        fi,

    /// Provide return function for block.
    /// Be careful with lazy lists, for example
    /// withExit do e: 1 :. \(e []) done
    /// fails with exit out scope error..
    withExit f is (('a -> 'b) -> 'a) -> 'a =
        EscapeFun#with(f) unsafely_as 'a,

    threadLocal initialValue is 'a -> {var value is 'a} =
        class Local extends java.lang.ThreadLocal
            Object initialValue() initialValue
        end;
        tl = new Local();
        {
            get value () = tl#get() unsafely_as 'a,
            set value v  = tl#set(v)
        },

    stackTraceString ex is ~java.lang.Throwable -> string =
        sw = new java.io.StringWriter();
        ex#printStackTrace(new java.io.PrintWriter(sw));
        sw#toString(),

    /// The UTF-8 charset.
    utf8 = "UTF-8",

    /// Yeti version string. Don't try simple string comparision on it.
    /// At least convert it to number list with something like
    /// map number (strSplit '\D+' yetiRuntimeVersion) >= [0,9]
    yetiRuntimeVersion = "0.9.6+"
}
